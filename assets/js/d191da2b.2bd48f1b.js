"use strict";(self.webpackChunknodearch_website=self.webpackChunknodearch_website||[]).push([[745],{3923:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"introduction/philosophy-design-principles","title":"Design Principles","description":"NodeArch was built with a clear mission: to make backend development in Node.js structured, maintainable, and scalable \u2014 without sacrificing the flexibility developers love.","source":"@site/docs/introduction/philosophy-design-principles.md","sourceDirName":"introduction","slug":"/introduction/philosophy-design-principles","permalink":"/docs/introduction/philosophy-design-principles","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Key Features","permalink":"/docs/introduction/key-features"},"next":{"title":"Installation","permalink":"/docs/getting-started/installation"}}');var t=i(4848),o=i(8453);const r={},l="Design Principles",a={},c=[{value:"Convention Over Configuration",id:"convention-over-configuration",level:2},{value:"Dependency Injection as a Foundation",id:"dependency-injection-as-a-foundation",level:2},{value:"Modular by Design",id:"modular-by-design",level:2},{value:"Balanced Opinionation",id:"balanced-opinionation",level:2},{value:"TypeScript First",id:"typescript-first",level:2},{value:"Testability at Every Layer",id:"testability-at-every-layer",level:2},{value:"Integration, Not Reinvention",id:"integration-not-reinvention",level:2},{value:"Clear Lifecycle Management",id:"clear-lifecycle-management",level:2},{value:"Lightweight and Production-Ready",id:"lightweight-and-production-ready",level:2},{value:"Philosophy in One Sentence",id:"philosophy-in-one-sentence",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"design-principles",children:"Design Principles"})}),"\n",(0,t.jsxs)(n.p,{children:["NodeArch was built with a clear mission: to make backend development in Node.js ",(0,t.jsx)(n.strong,{children:"structured, maintainable, and scalable"})," \u2014 without sacrificing the flexibility developers love."]}),"\n",(0,t.jsxs)(n.p,{children:["It draws inspiration from enterprise frameworks like ",(0,t.jsx)(n.strong,{children:"Spring (Java)"})," and ",(0,t.jsx)(n.strong,{children:".NET (C#)"})," while embracing the asynchronous, lightweight nature of Node.js. Here's a deeper look at the core philosophy and design principles that guide NodeArch."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"convention-over-configuration",children:"Convention Over Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["NodeArch encourages consistency and simplicity through ",(0,t.jsx)(n.strong,{children:"conventions"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Projects follow a standard structure with intuitive file and module organization."}),"\n",(0,t.jsx)(n.li,{children:"Decorators simplify configuration, reducing boilerplate."}),"\n",(0,t.jsx)(n.li,{children:"Developers can focus more on building features and less on wiring things together."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"dependency-injection-as-a-foundation",children:"Dependency Injection as a Foundation"}),"\n",(0,t.jsxs)(n.p,{children:["Everything in NodeArch is designed around ",(0,t.jsx)(n.strong,{children:"Dependency Injection (DI)"})," \u2014 enabling loosely coupled, testable, and modular components."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Services are registered and resolved through a centralized container."}),"\n",(0,t.jsxs)(n.li,{children:["The DI system supports multiple lifetimes: ",(0,t.jsx)(n.code,{children:"singleton"}),", ",(0,t.jsx)(n.code,{children:"request scoped"}),", and ",(0,t.jsx)(n.code,{children:"transient"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Encourages clean separation between infrastructure and business logic."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"modular-by-design",children:"Modular by Design"}),"\n",(0,t.jsxs)(n.p,{children:["NodeArch is built on the concept of a ",(0,t.jsx)(n.strong,{children:"Component"}),", which is a class that could be a Controller, Service, Repository, Config, Hook, or a generic Component."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You organize components into folders that represent modules/domains."}),"\n",(0,t.jsxs)(n.li,{children:["Then, you create a NodeArch ",(0,t.jsx)(n.strong,{children:"App"})," by pointing it to the root folder of these components."]}),"\n",(0,t.jsxs)(n.li,{children:["Apps can also be extended using other ",(0,t.jsx)(n.strong,{children:"Apps"})," \u2014 which may be:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Official extensions published as npm modules"}),"\n",(0,t.jsx)(n.li,{children:"Internal or external reusable apps created by the developer"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"This enables recursive composition: apps can be built on top of other apps which themselves can use other apps \u2014 creating powerful reusable systems."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"balanced-opinionation",children:"Balanced Opinionation"}),"\n",(0,t.jsxs)(n.p,{children:["NodeArch provides ",(0,t.jsx)(n.strong,{children:"just enough structure"})," to guide you \u2014 without locking you in."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It\u2019s opinionated about architecture, not about your tech stack."}),"\n",(0,t.jsxs)(n.li,{children:["Supports Express (via ",(0,t.jsx)(n.code,{children:"@nodearch/express"}),") but leaves room for other integrations in the future."]}),"\n",(0,t.jsx)(n.li,{children:"You can use any database, ORM, or library \u2014 NodeArch won't stand in your way."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"typescript-first",children:"TypeScript First"}),"\n",(0,t.jsxs)(n.p,{children:["NodeArch is built entirely with ",(0,t.jsx)(n.strong,{children:"TypeScript"}),", offering a modern and type-safe developer experience."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Full type safety across services, controllers, routes, and decorators."}),"\n",(0,t.jsx)(n.li,{children:"Leverages TypeScript decorators to provide a clean and declarative API."}),"\n",(0,t.jsx)(n.li,{children:"Eliminates common runtime bugs with powerful compile-time validation."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"testability-at-every-layer",children:"Testability at Every Layer"}),"\n",(0,t.jsxs)(n.p,{children:["Testability is not an afterthought \u2014 it\u2019s ",(0,t.jsx)(n.strong,{children:"baked into the design"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Every service, controller, and middleware can be unit tested in isolation."}),"\n",(0,t.jsx)(n.li,{children:"DI container makes mocking and injection straightforward."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mocha"})," is supported out of the box as the test runner."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"integration-not-reinvention",children:"Integration, Not Reinvention"}),"\n",(0,t.jsxs)(n.p,{children:["NodeArch aims to ",(0,t.jsx)(n.strong,{children:"integrate seamlessly with the existing ecosystem"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Works with Express, TypeORM, Prisma, Redis, Kafka, and more."}),"\n",(0,t.jsx)(n.li,{children:"Supports OpenAPI decorators, validation tools like Joi, and more."}),"\n",(0,t.jsx)(n.li,{children:"Encourages composition over reinvention."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"clear-lifecycle-management",children:"Clear Lifecycle Management"}),"\n",(0,t.jsxs)(n.p,{children:["NodeArch includes a ",(0,t.jsx)(n.strong,{children:"lifecycle hook system"})," that allows developers to plug into application startup and shutdown routines."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"onStart"})," and ",(0,t.jsx)(n.code,{children:"onStop"})," to handle background jobs, connections, or logging."]}),"\n",(0,t.jsx)(n.li,{children:"Easily manage resource cleanup and startup tasks."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"lightweight-and-production-ready",children:"Lightweight and Production-Ready"}),"\n",(0,t.jsxs)(n.p,{children:["NodeArch apps compile into ",(0,t.jsx)(n.strong,{children:"lean, production-ready builds"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Minimal runtime footprint"}),"\n",(0,t.jsx)(n.li,{children:"Easy to deploy in containers, VMs, or serverless environments"}),"\n",(0,t.jsx)(n.li,{children:"Designed with CI/CD and DevOps best practices in mind"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"philosophy-in-one-sentence",children:"Philosophy in One Sentence"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u201cEmpower developers to build clean, scalable, and maintainable backend applications \u2014 without reinventing the wheel.\u201d"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);