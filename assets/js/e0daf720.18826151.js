"use strict";(self.webpackChunknodearch_website=self.webpackChunknodearch_website||[]).push([[6090],{8169:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"core-concepts/lifecycle","title":"Lifecycle","description":"NodeArch applications follow a well-defined lifecycle that ensures your app and its extensions are loaded, initialized, and started in a consistent and extensible way. This document explains what happens when you run nodearch start and how the framework manages your app\'s lifecycle.","source":"@site/docs/core-concepts/lifecycle.md","sourceDirName":"core-concepts","slug":"/core-concepts/lifecycle","permalink":"/docs/core-concepts/lifecycle","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Hello World","permalink":"/docs/getting-started/hello-world"},"next":{"title":"App","permalink":"/docs/core-concepts/app"}}');var o=s(4848),t=s(8453);const r={},c="Lifecycle",l={},d=[{value:"1. CLI Bootstrapping",id:"1-cli-bootstrapping",level:2},{value:"2. Initialization Phase (<code>init()</code>)",id:"2-initialization-phase-init",level:2},{value:"3. Startup Phase (<code>start()</code>)",id:"3-startup-phase-start",level:2},{value:"4. Shutdown Phase (<code>stop()</code>)",id:"4-shutdown-phase-stop",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"lifecycle",children:"Lifecycle"})}),"\n",(0,o.jsxs)(n.p,{children:["NodeArch applications follow a well-defined lifecycle that ensures your app and its extensions are loaded, initialized, and started in a consistent and extensible way. This document explains what happens when you run ",(0,o.jsx)(n.code,{children:"nodearch start"})," and how the framework manages your app's lifecycle."]}),"\n",(0,o.jsx)(n.h2,{id:"1-cli-bootstrapping",children:"1. CLI Bootstrapping"}),"\n",(0,o.jsxs)(n.p,{children:["When you run ",(0,o.jsx)(n.code,{children:"nodearch start"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The CLI scans the current directory for a file named ",(0,o.jsx)(n.code,{children:"nodearch"})," to locate your app."]}),"\n",(0,o.jsxs)(n.li,{children:["Once found, it loads the app and looks for the main entry point, typically ",(0,o.jsx)(n.code,{children:"main.ts"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"main.ts"})," file should export a class that extends the ",(0,o.jsx)(n.code,{children:"App"})," class from ",(0,o.jsx)(n.code,{children:"@nodearch/core"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["The CLI creates an instance of your app and invokes two main built-in methods: ",(0,o.jsx)(n.code,{children:"init()"})," and ",(0,o.jsx)(n.code,{children:"start()"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"2-initialization-phase-init",children:["2. Initialization Phase (",(0,o.jsx)(n.code,{children:"init()"}),")"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"init()"})," method is responsible for setting up the core of your application:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Core Components"}),": Loads and initializes essential components such as Logger, AppContext, and ConfigManager."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Extensions"}),": Loads any extensions. Extensions are themselves NodeArch apps, so the same loading logic applies recursively."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Registering Extensions"}),": Integrates loaded extensions into the main app."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Component Loading"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Uses the ",(0,o.jsx)(n.code,{children:"components.url"})," specified in your app to scan directories recursively for ",(0,o.jsx)(n.code,{children:".ts"}),"/",(0,o.jsx)(n.code,{children:".js"})," files (depending on the mode)."]}),"\n",(0,o.jsx)(n.li,{children:"Loads these files using Node.js dynamic import."}),"\n",(0,o.jsxs)(n.li,{children:["Filters loaded files to keep only components (classes decorated with NodeArch built-in or custom decorators, e.g., ",(0,o.jsx)(n.code,{children:"@Controller"}),", ",(0,o.jsx)(n.code,{children:"@Service"}),")."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Hook Registration"}),": Registers hooks from both the main app and any extension that exports a hook (e.g., decorated with ",(0,o.jsx)(n.code,{children:"@Hook({ export: true })"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dependency Injection & Scopes"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["When a component is injected into another, the framework resolves dependencies based on the defined component scope, either globally (via ",(0,o.jsx)(n.code,{children:"components.scope"}),") or per component (via the decorator, e.g., ",(0,o.jsx)(n.code,{children:"@Service({ scope: ComponentScope.SINGLETON })"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Scopes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ComponentScope.SINGLETON"}),": The component is created once and shared across the app (default)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ComponentScope.TRANSIENT"}),": A new instance is created each time the component is injected. Useful for stateless components."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ComponentScope.REQUEST"}),": A new instance is created for each request (not limited to HTTP requests; could be a message, scheduled task, etc.)."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"3-startup-phase-start",children:["3. Startup Phase (",(0,o.jsx)(n.code,{children:"start()"}),")"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"start()"})," method is called after initialization."]}),"\n",(0,o.jsxs)(n.li,{children:["It calls and awaits ",(0,o.jsx)(n.code,{children:"onStart()"})," for all registered hooks."]}),"\n",(0,o.jsxs)(n.li,{children:["This is where the main logic of your app and extensions runs. For example, a hook from ",(0,o.jsx)(n.code,{children:"@nodearch/express"})," may retrieve all controllers, parse routes and middlewares, register them in an Express app, and start the HTTP server."]}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"4-shutdown-phase-stop",children:["4. Shutdown Phase (",(0,o.jsx)(n.code,{children:"stop()"}),")"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["When the app is about to exit, the ",(0,o.jsx)(n.code,{children:"stop()"})," method is called."]}),"\n",(0,o.jsxs)(n.li,{children:["This triggers ",(0,o.jsx)(n.code,{children:"onStop()"})," on all registered hooks, allowing for graceful shutdown and cleanup."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.p,{children:"By following this lifecycle, NodeArch ensures that your app and its extensions are loaded, initialized, started, and stopped in a predictable and extensible manner."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var i=s(6540);const o={},t=i.createContext(o);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);